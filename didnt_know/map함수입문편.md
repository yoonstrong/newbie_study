[toc]

# `map`은 게으른 요리사 레시피

> "map은 당장 요리하지 않고, '요리법(레시피)'만 가지고 있는 게으른 요리사와 같기 때문"



## 1\. `map`은 '요리법'이다

코드를 보면서 이해해 봅시다. 숫자 리스트의 각 요소를 2배로 만드는 작업을 하고 싶다고 가정해 봅시다.

```python
numbers = [10, 20, 30]

# "각 숫자를 2배로 만들어라" 라는 '요리법'을 만듭니다.
recipe = map(lambda x: x * 2, numbers)

# 요리법(recipe)을 출력해 봅시다.
print(recipe)
```

**실행 결과:**

```
<map object at 0x10e7b9c10>
```

결과가 `[20, 40, 60]`이 아니라 `map object at ...`라고 나옵니다.

이건 파이썬이 `"알겠습니다! 'numbers'에 있는 각 재료를 2배로 만들라는 '요리법'은 제가 잘 가지고 있어요. 메모리(0x10e7b9c10)에 보관 중입니다."`라고 대답하는 것과 같습니다.

`map`은 함수와 리스트를 받아서 '어떻게 처리할지'에 대한 계획, 즉 '요리법'만 만들 뿐 실제로 그 작업을 바로 실행하지는 않습니다.



-----



## 2\. 결과를 보려면 '요리'를 시켜야 한다

이 게으른 요리사에게 실제로 요리를 시켜서 결과물을 눈으로 보려면 어떻게 해야 할까요?
`"이제 그 요리법대로 요리해서 상에 차려줘!"`라고 명확하게 지시해야 합니다.



### 방법 1: `list()`로 상 차리기 (가장 흔한 방법)

`list()`로 `map`을 감싸는 것은 "요리법에 있는 모든 재료를 한 번에 다 요리해서, '리스트'라는 접시에 순서대로 담아줘\!"라고 지시하는 것과 같아요.

```python
# '요리법(recipe)'대로 요리해서 list 접시에 담아달라고 요청합니다.
dishes = list(recipe)

# 결과가 담긴 접시를 출력합니다.
print(dishes)
```

**실행 결과:**

```
[20, 40, 60]
```

이제야 우리가 원했던 결과가 보입니다. `list()`가 `map`에게 일을 시켜서 실제 결과물을 만들어 낸 것입니다.



### 방법 2: `for`문으로 하나씩 요리하기

`for` 반복문은 "요리사님, 요리 하나씩 완성될 때마다 바로바로 가져다주세요\!"라고 요청하는 것과 같습니다.

```python
# '요리법(recipe)'을 for문으로 순회합니다.
# for문은 recipe에게 "다음 요리 주세요"를 계속 요청합니다.
for dish in recipe:
    print(dish)
```

**실행 결과:**

```
20
40
60
```

`for`문이 `map` 객체를 순회하면서 요소를 하나씩 요청할 때마다 `map`이 그제야 하나씩 계산해서 결과를 내어주는 방식입니다.



-----



## 3\. 왜 이렇게 '게으르게' 만들었을까?

바로 **효율성** 때문입니다.

만약 처리해야 할 데이터가 10억 개라고 상상해 보세요. `map`이 요리법만 만들지 않고 처음부터 10억 개를 전부 계산해서 리스트로 만든다면 엄청난 시간과 메모리가 낭비될 거예요.

하지만 `map`은 '게으르게' 계획만 세워두고, 우리가 **결과를 달라고 요청하는 시점에 필요한 만큼만** 계산합니다. 이런 방식을 통해 파이썬은 매우 효율적으로 대용량 데이터를 처리할 수 있습니다.



-----



## 4\. 또 다른 게으른 친구들: `range`와 `zip`

파이썬에는 `map`처럼 게으르게 동작해서 효율적인 친구들이 더 있습니다.

### `range` - 숫자 생성 계획서

`range(100)`은 0부터 99까지의 숫자가 담긴 리스트가 아닙니다. "요청하면 0부터 99까지 숫자를 차례대로 줄 수 있다"는 **약속 또는 계획서**와 같습니다.

```python
# 0부터 99까지 숫자를 만들 '계획'
num_plan = range(100)

# 계획서 자체를 출력
print(num_plan)
# >> range(0, 100)

# list()로 모든 숫자를 만들어달라고 요청
print(list(num_plan))
# >> [0, 1, 2, ..., 99]
```

`range` 덕분에 숫자 100개를 미리 메모리에 저장하지 않아도 됩니다.



### `zip` - 짝매칭 계획서

`zip`은 여러 리스트의 요소들을 어떻게 짝지을지에 대한 계획을 세웁니다. 마치 옷의 지퍼처럼, 우리가 채울 때만 한 칸씩 짝이 맞춰집니다.

```python
names = ['철수', '영희']
scores = [90, 85]

# 두 리스트를 짝지을 '계획'
pair_plan = zip(names, scores)

# 계획 자체를 출력
print(pair_plan)
# >> <zip object at ...>

# list()로 모든 짝을 만들어달라고 요청
print(list(pair_plan))
# >> [('철수', 90), ('영희', 85)]
```

이처럼 `map`, `range`, `zip`은 모두 **'일단 계획만 세워두고, 필요할 때 요청하면 그때 처리해주는'** 게으르고 효율적인 방식으로 동작합니다.



## 핵심 요약

  * **`map()`, `range()`, `zip()`**: "이렇게 처리하라"는 **계획 또는 레시피**일 뿐, 아직 실행되지 않은 상태입니다.
  * **`list(...)`**: "계획을 **전부 실행**해서 그 결과를 리스트에 담아줘\!"라는 명령입니다.
  * **`for item in ...`**: "계획을 **하나씩 실행**해서 보여줘\!"라는 명령입니다.

따라서 `map object`나 `zip object`, `range(0, 100)` 같은 메시지를 본다면, "아, 파이썬이 내 지시를 이해하고 실행할 계획을 세웠구나. 이제 `list()`나 `for`문으로 실행만 시키면 되겠다\!"라고 생각하시면 됩니다.

