[toc]

# map과 지연 평가: '이터레이터(Iterator)'의 이해

> "왜 `map`은 `list()`로 감싸야 결과가 보이나요?"라는 질문의 핵심에는 '지연 평가(Lazy Evaluation)'라는 중요한 프로그래밍 개념이 있습니다.



## 1\. `map` 객체는 '이터레이터(Iterator)'입니다

`map` 함수는 리스트와 같은 '이터러블(Iterable)' 객체를 받아, 그 결과로 '이터레이터(Iterator)'를 반환합니다.

  * `'이터러블 (Iterable)'`
    * `for`문으로 하나씩 요소를 꺼낼 수 있는 객체입니다. 
    * 리스트, 튜플, 문자열 등이 여기에 해당합니다. 말 그대로 '반복 가능한' 객체입니다.

  * `'이터레이터 (Iterator)'`
    * 값을 차례대로 꺼낼 수 있는 '흐름(stream)'을 가진 객체입니다. 
    * `next()` 함수를 호출하여 다음 값을 생성할 수 있으며, 한 번 소비하면 다시 사용할 수 없습니다.


`map`이 반환하는 이터레이터는 '어떻게 다음 값을 계산할지'에 대한 방법만 알고 있을 뿐, 아직 실제 값을 메모리에 만들어두지 않은 상태입니다. 이것이 바로 '지연 평가 (Lazy Evaluation)'의 핵심 원리입니다.

```python
numbers = [10, 20, 30] # '이터러블' 객체

# map은 이터러블을 받아 '이터레이터'를 반환합니다.
iterator_obj = map(lambda x: x * 2, numbers)

# 이터레이터 객체 자체를 출력합니다.
# 아직 계산이 실행되지 않았습니다.
print(iterator_obj)
```

**실행 결과:**

```
<map object at 0x10e7b9c10>
```

이 결과는 "값을 계산할 준비가 된 이터레이터 객체가 메모리에 있다"는 의미입니다.

실제 값 `[20, 40, 60]`은 아직 메모리에 존재하지 않습니다.



-----



## 2\. 이터레이터를 '소비'하여 결과 보기

이터레이터가 가진 값을 실제로 보려면, 이터레이터를 '소비'해야 합니다.

> `소비`란 이터레이터에게 `next()`를 계속 요청하여 모든 값을 소진시키는 행위를 말합니다.



### 방법 1: `list()`로 이터레이터 소비하기

`list()`와 같은 생성자는 이터레이터를 인자로 받아, 그 안의 모든 요소를 꺼내(소비하여) 새로운 리스트를 만듭니다. 이 과정에서 지연되었던 모든 계산이 한 번에 수행됩니다.

```python
# list() 생성자가 이터레이터를 '소비'하여 모든 계산을 실행하고 리스트로 만듭니다.
result_list = list(iterator_obj)

print(result_list)
```

**실행 결과:**

```
[20, 40, 60]
```



### 방법 2: `for`문으로 이터레이터 소비하기

`for` 반복문 역시 내부적으로 이터레이터의 `next()`를 호출하여 값을 하나씩 꺼내 오는 대표적인 '소비자'입니다.

```python
# for 반복문이 이터레이터를 순회하며 값을 하나씩 소비합니다.
for item in iterator_obj:
    print(item)

# 중요: 위에서 list()로 이미 이터레이터를 소비했다면
# 이 for문은 아무것도 출력하지 않습니다. 이터레이터는 일회용이기 때문입니다.
```



---



## 3\. 왜 지연 평가를 사용할까? '메모리 효율성'

지연 평가의 가장 큰 장점은 '메모리 효율성'입니다.

만약 처리해야 할 데이터가 10억 개라면, 결과를 미리 전부 계산해서 리스트로 만드는 것은 엄청난 메모리를 차지할 것입니다. 하지만 이터레이터는 값을 요청받을 때마다 단 하나만 계산해서 돌려주므로, 아무리 큰 데이터라도 최소한의 메모리만 사용하여 처리할 수 있습니다.



-----



## 4\. 지연 평가를 사용하는 다른 내장 함수들

파이썬의 지연 평가 원리는 `map` 함수에만 국한되지 않습니다. `range`, `zip`과 같은 다른 여러 내장 함수들도 동일한 이터레이터 패턴을 사용하여 메모리 효율성을 극대화합니다.

### `range`

Python에서 `range()`는 모든 숫자를 담은 리스트를 반환하지 않습니다. 대신, 요청 시 숫자를 생성하는 매우 메모리 효율적인 객체를 반환합니다. 이 객체는 시작, 끝, 간격 값만 저장할 뿐, 모든 중간 값을 저장하지 않습니다.

```python
# range 객체는 모든 값을 메모리에 생성하지 않습니다.
num_obj = range(100)
print(num_obj)
# >> range(0, 100)

# list()로 소비하여 모든 값을 구체화합니다.
print(list(num_obj))
# >> [0, 1, 2, ..., 99]
```



### `zip`

`zip()` 또한 여러 이터러블을 인자로 받아, 각 이터러블의 요소를 튜플로 묶어주는 '이터레이터'를 반환합니다. `map`과 마찬가지로, `zip` 이터레이터도 소비될 때 비로소 튜플을 하나씩 생성합니다.

```python
names = ['철수', '영희']
scores = [90, 85]

# zip은 튜플을 생성하는 이터레이터를 반환합니다.
zip_iterator = zip(names, scores)
print(zip_iterator)
# >> <zip object at ...>

# list()로 소비하여 모든 튜플을 생성합니다.
print(list(zip_iterator))
# >> [('철수', 90), ('영희', 85)]
```

이처럼 이터레이터를 반환하여 지연 평가를 활용하는 것은 파이썬의 매우 흔하고 강력한 디자인 패턴입니다.



## 핵심 요약

  * `map()`, `range()`, `zip()` 등
    * '이터레이터(Iterator)' 또는 그와 유사한 객체를 반환합니다. 이들은 '지연 평가(Lazy Evaluation)' 원리에 따라 동작합니다.
  * `list(...)`
    * 이터레이터를 '소비'하여 모든 요소를 계산하고, 그 결과를 리스트라는 새로운 자료구조로 '구체화'하는 과정입니다.
  * 기술적 흐름 
    * `함수(이터러블)` → `이터레이터` 생성 → `list()`로 `소비` → 지연되었던 계산 실행 → 결과 `리스트` 반환.
